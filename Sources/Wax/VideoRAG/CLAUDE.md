# Sources/Wax/VideoRAG Module

## Purpose
On-device RAG over local and Photos videos. Ingests videos by segmenting them into fixed time windows, computing keyframe embeddings per segment, optionally indexing host-supplied transcripts, and returning RAG-ready context grouped by video with timecoded segment hits.

## Key Types

| Type | Role |
|------|------|
| `VideoRAGOrchestrator` | Actor. Owns a `Wax` store and `WaxSession`. Manages file/Photos video ingest, recall, delete, and in-memory index. |
| `VideoRAGConfig` | Struct. Host-tunable: segment duration/overlap, max segments, embed pixel size, transcript byte cap, search topK, hybrid alpha, thumbnail output. |
| `VideoQuery` | Struct. Query params: text, time range, video ID allowlist, result limit, segment limit per video, context budget. |
| `VideoRAGContext` | Struct. Recall output: items + diagnostics (used tokens, degraded count). |
| `VideoRAGItem` | Struct. Per-video result: videoID, score, evidence, summary text, segment hits. |
| `VideoSegmentHit` | Struct. Per-segment: timecodes, score, evidence, transcript snippet, optional thumbnail. |
| `VideoID` | Struct. Type-safe identifier with source (`.file` / `.photos`) + string ID. |
| `VideoFile` | Struct. Input for file-based ingestion: id, URL, optional capture date. |
| `VideoContextBudget` | Struct. Token/thumbnail/transcript-line caps. |
| `VideoTranscriptProvider` | Protocol. Host-supplied transcript generation. |
| `VideoTranscriptRequest` / `VideoTranscriptChunk` | Structs. Timed transcript chunks in milliseconds. |
| `VideoIngestError` | Error enum. File missing, unsupported platform, invalid video, dimension mismatch. |

## Frame Kind Hierarchy

```
video.root     -- One per video. Holds metadata (source, duration, capture time). No embedding.
video.segment  -- One per time window. Holds keyframe embedding + transcript text. Child of root.
```

## Segmentation

Videos are divided into fixed-duration windows (default: 10s, configurable overlap). Each segment gets:
- A keyframe image extracted at the segment midpoint via `AVAssetImageGenerator`.
- An embedding from the host's `MultimodalEmbeddingProvider`.
- Transcript text mapped from overlapping `VideoTranscriptChunk`s (>=250ms overlap threshold).

`makeSegments()` produces a `[SegmentPlan]` with `startMs`, `endMs`, `midMs`, `index`, and `count`.

## Recall Pipeline

1. Build query embedding from text via cached embedder.
2. Determine search mode (hybrid if both text + embedding, else textOnly/vectorOnly).
3. For constraint-only queries (no text, no embedding), filter to root frames and use timeline fallback.
4. Run unified search with optional video ID allowlist as frame filter.
5. Group results by root -> per-video, pick top segments per video.
6. Load transcript text for selected segments.
7. Build summary text (transcript-based or metadata-based fallback).
8. Apply token budget deterministically.
9. Optionally attach keyframe thumbnails.

## Capture-Time Semantics

All segment frames share the video's capture timestamp (not their segment midpoint). This means `VideoQuery.timeRange` filters by when the video was captured, not by segment position within the video.

## Concurrency Model

- `VideoRAGOrchestrator` is an actor; all state is isolated.
- File ingestion is sequential per video (keyframe extraction uses `AVAssetImageGenerator` synchronously).
- Segment writes are batched via `session.putBatch()` for I/O efficiency.
- Query embedding is cached via `EmbeddingMemoizer`.

## Dependencies

- `WaxCore`, `WaxVectorSearch`
- `Foundation`, `CoreGraphics`, `ImageIO`, `UniformTypeIdentifiers`
- Platform-conditional: `AVFoundation`, `Photos`

## Constraints (v1)

- Wax does not transcribe audio; the host app provides `VideoTranscriptProvider`.
- No clip bytes are stored; Wax stores text + metadata only.
- Photos video ingestion is offline-only (`isNetworkAccessAllowed = false`).
- Thumbnails are only available for file-backed videos (not Photos) in v1.

## Common Pitfalls

- `embedder.normalize` must be `true` for Metal; validated at init.
- `requireOnDeviceProviders` checks both embedder and transcript provider execution modes.
- Segment/keyframe count must match; `writeSegments` throws on mismatch.
- `cappedUTF8` handles mid-codepoint truncation safely by removing bytes until valid UTF-8.


<claude-mem-context>
# Recent Activity

<!-- This section is auto-generated by claude-mem. Edit content outside the tags. -->

*No recent activity*
</claude-mem-context>